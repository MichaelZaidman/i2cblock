# SPDX-License-Identifier: MIT
#
# Copyright (C) 2022 Michael Zaidman <michael.zaidman@gmail.com>
#
# The i2cperf is a Linux utility to test the large IO chunks' capabilities
# and benchmark performance of the I2C controllers and Linux kernel I2C bus
# drivers.
#
# WARNING: the utility can be extremely dangerous if used improperly. It can
#          confuse your I2C bus, cause data loss, or have more serious side
#          effects. Be extremely careful using this tool.
#
#!/bin/bash

(return 0 2>/dev/null) && sourced=1 || sourced=0

if [ $sourced == 1 ]; then
	er_exit="return"
	ok_exit="return"
else
	er_exit="exit 1"
	ok_exit="exit 0"
fi

progname=$(basename $0)
verbose=0
fillmode=0
dumpmode=0
xfersize=16
offsize=1

# Default range to preserve the FT260 configuration resided in the first half
# of the 24c02 EEPROM mounted on the UMFT260EV1A EVB module.
frst=0x80
last=0xef
stat=0
width=80

fillmode_desc=(
	"Fill block with zeros via i2ctransfer"
	"Fill block with increment via i2ctransfer by chunks"
	"Fill block with increment via i2cset byte by byte"
	"Fill block with pseudo random via i2ctransfer by chunks"
	)

dumpmode_desc=(
	"Read block via i2cdump byte by byte"
	"Read block via i2ctransfer by chunks"
	)

offsize_desc=(
	"One byte offset like in 24C01 - 24C16 EEPROMs"
	"Two bytes offest, for larger than 256B EEPROMs"
	)

function usage() {
	 cat << help

	 Usage: $progname [-h] [-v] -S] [-f MODE] [-d MODE] [-o SIZE] [-s SIZE] [-r FIRST-LAST] BUS ADDRESS

		 BUS                    I2C bus master device number
		 ADDRESS                EEPROM device address (0x50 - 0x57)

		 -h, --help             Show this help message and exit
		 -v, --verbose          More verbose output
		 -S, --stat             Print statistics

		 -d, --dumpmode MODE    Read data mode:
help
	for ((i = 1; i <= ${#dumpmode_desc[@]}; i++))
		do echo -e "\t\t\t\t\t$i - ${dumpmode_desc[$((i - 1))]}"; done
	printf '\n%s\n' "		 -f, --fillmode MODE    Write data mode:"
	for ((i = 1; i <= ${#fillmode_desc[@]}; i++))
		do echo -e "\t\t\t\t\t$i - ${fillmode_desc[$((i - 1))]}"; done
	cat << help

		 -r, --range FIRST-LAST Address range to operate
		 -s, --xfersize SIZE    Data chunk size in bytes

		 -o, --offsize SIZE     Offset (addr in chip addr space) size:
help
	for ((i = 1; i <= ${#offsize_desc[@]}; i++))
		do echo -e "\t\t\t\t\t$i - ${offsize_desc[$((i - 1))]}"; done
}

if [ $# -eq 0 ]; then
	usage
	eval "$er_exit"
fi

function get_range() {
	[[ "$1" != *"-"* ]] && echo "wrong range delimiter" && eval "$er_exit"
	arr=(${1//-/ })
	frst=${arr[0]}
	last=${arr[1]}
}

OPTS=$(getopt -o "hf:d:r:s:o:vS" \
	--long "help,fillmode:,dumpmode:,range:,xfersize:,offsize:,verbose,stat" \
	-n "$progname" -- "$@")

if [ $? != 0 ] ; then
	echo "Error in command line arguments." >&2
	usage
	eval "$er_exit"
fi
eval set -- "$OPTS"

while true; do
	case "$1" in
		-h | --help ) usage; eval "$ok_exit" ;;
		-r | --range ) get_range "$2"; shift 2 ;;
		-f | --fillmode ) fillmode="$2"; shift 2 ;;
		-d | --dumpmode ) dumpmode="$2"; shift 2 ;;
		-s | --xfersize ) xfersize="$2"; shift 2 ;;
		-o | --offsize ) offsize="$2"; shift 2 ;;
		-v | --verbose ) verbose=1; shift 1 ;;
		-S | --stat ) stat=1; shift 1 ;;
		-- ) shift; break ;;
		* ) break ;;
	esac
done

if [ $# -ne 2 ]; then
	usage
	eval "$er_exit"
fi
bus=$1
addr=$2

function core_stat() {
	xfers=$(echo "$total_data / $xfersize" | bc)
	data_time=$(echo "scale=6; $total_time / ($total_data * 8)" | bc)

	[[ $fillmode > 0 ]] && addr_byte=1 || addr_byte=2

	# prot_bits = xfers * start, stop, and repeated start (for read) bits
	prot_bits=$((xfers * (addr_byte + 1)))

	# data_bits = data bytes * 8 bits + 1 ack bit
	data_bits=$(echo "scale=0; $total_data * 9" | bc)

	# addr_bits = xfers * (offsize + addr bytes) * (8 bits + 1 ack bit)
	addr_bits=$(echo "scale=0; $xfers * ($offsize + $addr_byte) * 9" | bc)

	baud_time=$(echo "scale=8; $total_time / \
		   ($data_bits + $addr_bits + $prot_bits)" | bc)

	data_rate=$(echo "scale=0; 1 / $data_time" | bc)
	baud_rate=$(echo "scale=0; 1 / $baud_time" | bc)
	efficiency=$(echo "scale=0; $data_rate * 100 / $baud_rate" | bc)

	echo -e "\nPerformance stats:"
	echo -e "  $1"
	header="  %-10s %13s %14s %12s %9s %12s\n  "
	format="  %-10d %-14d %-14d %-12d %-11d %-12d\n\n"

	printf "$header" "baudrate" "datarate(bps)" "efficiency(%)" \
		"datasize(B)" "totalIOs" "IOsize(B)"

	printf '%.0s-' {1..75}; echo

	printf "$format" $baud_rate $data_rate $efficiency \
		$total_data $xfers $xfersize
}

function dump_stat() {
	core_stat "${dumpmode_desc[$(( dumpmode - 1 ))]}"
}

function fill_stat() {
	core_stat "${fillmode_desc[$(( fillmode - 1 ))]}"
}

[ $verbose -eq 1 ] && echo range: first=$frst last=$last

function run() {
	[ $verbose -eq 1 ] && echo "sudo $@"
	if [ $stat -eq 1 ]; then
		start_time=$(date +%s.%N)
		sudo "$@" || return
		stop_time=$(date +%s.%N)
		diff_time=$(echo "$stop_time - $start_time" | bc)
		diff_time=${diff_time%???}
		total_time=$(echo "$total_time + $diff_time" | bc)
	else
		sudo "$@"
	fi
}

function setoffset() {
	eval $1=$( printf "0x%0*x" 4 $4 )
	eval $2=$( printf "0x%x" "$(( xx >> 0x8 ))" )
	eval $3=$( printf "0x%x" "$(( xx & 0xff ))" )
}

function dumpmode_1() {
	(( last - frst > 0xff )) && echo "err: invalid range" && eval "$er_exit"
	xfersize=1
	sudo i2cset -y -f $bus $addr $frst c
	run i2cdump -f -y -r $frst-$last $bus $addr c
}

function dumpmode_2() {
	step=$xfersize
	for (( i=$frst; i<$last; i=i+$step ))
	do
		(( last - i < step )) && step=$(( last - i + 1 ))
		setoffset xx hb lb $i
		echo -ne "$xx: "
		if [[ $offsize == "1" ]]; then
			run i2ctransfer -y -f $bus w$offsize@$addr $lb r$step
		else
			run i2ctransfer -y -f $bus w$offsize@$addr $hb $lb r$step
		fi
	done
}

function dumpblock() {
	total_time=0
	[ $verbose -eq 1 ] && echo dump: ${dumpmode_desc[$((dumpmode - 1))]}

	case "$dumpmode" in
		1|2 ) dumpmode_$dumpmode || eval "$er_exit" ;;
		* ) echo "err: invalid dump mode: $dumpmode"; eval "$er_exit" ;;
	esac

	total_data=$(( last - frst + 1 ))
	[ $stat -eq 1 ] && dump_stat
}

function fillcore() {
	for (( i=$frst; i<$last; i=i+$step ))
	do
		(( last - i < step )) && step=$(( last - i + 1 ))
		setoffset xx hb lb $i
		if [[ $offsize == "1" ]]; then
			run i2ctransfer -f -y $bus \
			    w$(( step + $offsize ))@$addr $lb $v$suffix \
			    || return
		else
			run i2ctransfer -f -y $bus \
			    w$(( step + $offsize ))@$addr $hb $lb $v$suffix \
			    || return
		fi
		if [ "$v_calc" = true ]; then
			v=$(( v + stepsd ))
			v=$( printf "0x%x" $(( v & 0xff )) )
		fi
	done
}

function fillmode_1() {
	suffix==
	v_calc=false
	v=0
	fillcore
}

function fillmode_2() {
	suffix=+
	stepsd=$step
	v_calc=true
	v=0
	fillcore
}

function fillmode_3() {
	for (( i=$frst; i<=$last; i=i+1 ))
	do
		setoffset xx hb lb $i
		if [[ $offsize == "1" ]]; then
			run i2cset -y -f $bus $addr $lb $lb
		else
			run i2cset -y -f $bus $addr $hb $lb $lb i
		fi
	done
	xfersize=1
}

function fillmode_4() {
	suffix=p
	stepsd=1
	v_calc=true
	v=0
	fillcore
}

function fillblock() {
	step=$xfersize
	total_time=0

	[ $verbose -eq 1 ] && echo fillblock: ${fillmode_desc[$((fillmode - 1))]}

	case "$fillmode" in
		1|2|3|4 ) fillmode_$fillmode || eval "$er_exit" ;;
		* ) echo "err: invalid fill mode: $fillmode"; eval "$er_exit" ;;
	esac

	total_data=$(( last - frst + 1 ))
	[ $stat -eq 1 ] && fill_stat
}

[[ $fillmode > 0 ]] && fillblock
[[ $dumpmode > 0 ]] && dumpblock
